#include <stdio.h>
#include <stdlib.h>

#define byte unsigned char

#define START_BYTE_CASE 0x5f
#define STOP_BYTE_CASE 0xa0
#define ESCAPE_BYTE_CASE 0x55

#define BUFFER_SIZE 250

byte start_byte = START_BYTE_CASE;
byte  stop_byte = STOP_BYTE_CASE;
byte  escape_byte = ESCAPE_BYTE_CASE;



struct state;
typedef void state_fn(struct state *);

struct state {
    state_fn *next;
    byte next_packet_size;
    byte buffer[BUFFER_SIZE];
    // muss immer aktuell sein, beim Interrupt entsprechend gesetzt werden
    byte fifo_len;
    byte bytes_read;
};

byte test_buffer[] = {1, 2, 3, START_BYTE_CASE, 1, START_BYTE_CASE, 2, 3, 4, 5, 6, 7, STOP_BYTE_CASE};
byte test_buffer_idx = 0;
state_fn start_fn, length_fn, length_esc_fn, read_data_fn, read_data_esc_fn;



byte internal_uart_buf_len() {
    return sizeof(test_buffer);
}

byte read_next_byte(struct state *s) {
    s->fifo_len--;
    return test_buffer[test_buffer_idx++];
}

void debug(const char *function_name, struct state *s) {
    printf("%s\n", function_name);
}

void reset_state(struct state *s) {
    debug(__func__, s);
    s->bytes_read = 0;
    s->next_packet_size = 0;
    // optional: memset(s->buffer, 0, BUFFER_SIZE)
}



void start_fn(struct state *s) {
    debug(__func__, s);
    byte current_byte = read_next_byte(s);
    switch (current_byte) {
    case START_BYTE_CASE:
	s->next = length_fn;
	break;
    default:
	break;
    }
}

void length_fn(struct state *s) {
    debug(__func__, s);
    byte current_byte = read_next_byte(s);
    switch (current_byte) {
    case START_BYTE_CASE:
    case STOP_BYTE_CASE:
	s->next = length_fn;
	break;
    case ESCAPE_BYTE_CASE:
	s->next = length_esc_fn;
	break;
    default:
	s->next_packet_size = current_byte;
	s->next = read_data_fn;
	break;
    }
}

void length_esc_fn(struct state *s) {
    debug(__func__, s);
    s->next_packet_size = read_next_byte(s);
    s->next = read_data_fn;
}

// Optimization: in der Funktion selbst loopen (spart function calls)
void read_data_fn(struct state *s) {
    debug(__func__, s);
    byte current_byte = read_next_byte(s);
    switch (current_byte) {
    case START_BYTE_CASE:
	reset_state(s);
	s->next = length_fn;
	break;
    case STOP_BYTE_CASE:
	printf("Stop: I've read %d bytes of %d bytes.\n", s->bytes_read, s->next_packet_size);
	reset_state(s);
	s->next = start_fn;
	break;
    case ESCAPE_BYTE_CASE:
	s->next = read_data_esc_fn;
	break;
    default:
	if (s->bytes_read > s->next_packet_size) {
	    printf("We're exceeding the new length\n"); // unescaped START in payload?
	}
	s->buffer[s->bytes_read] = current_byte;
	s->bytes_read++;
	break;
    }
}

void read_data_esc_fn(struct state *s) {
    debug(__func__, s);
    s->next = read_data_fn;
}

int main() {
    struct state *s = malloc(sizeof(struct state));
    s->fifo_len = sizeof(test_buffer);
    s->next = start_fn;
    while (s->fifo_len > 0) {
	s->next(s);
    }
    free(s);
    
}
